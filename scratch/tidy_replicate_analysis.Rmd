---
title: "Re-write of Sierra's Replicate Analysis Using Tidyverse"
date: '`r Sys.Date()`'
output: 
    bookdown::html_document2:
        toc: true
        toc_float: true
        df_print: paged
        code_folding: hide
---

# Questions for rewrite analysis
1. Input data files, specifically list of `identified_matched.txt` files and replicate information.

```{r setup}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse); packageVersion("tidyverse")
library(yaml); packageVersion("yaml")
library(here); packageVersion("here")
library(stringr); packageVersion("stringr")
```

# Summary
Rewriting Sierra's initial replicate analysis for evaluating within and between lab changeseq method performance.

# Approach
<!-- Brief description of individual analysis steps -->

1. Loading change seq pipeline output
2. Annotating changeseq data frame with sample pair/ replicate information
3. Summary/ Statistical Analysis  
    1. Summary Table  
    2. StJude - NIST Comparison

# Analysis
## Loading and Munging data (1 and 2 above)

Loading changeseq output tsv files into a single data frame
```{r message = FALSE}
## Using message = FALSE to avoid printing read_tsv message about column specifications

## List of changeseq output files
changeseq_lst <- list.files(path = here("data-raw"), 
                           pattern = "identified_matched.txt",
                           include.dirs = TRUE, full.names = TRUE, 
                           recursive = TRUE) %>% 
    set_names(basename(.))

changeseq_df <- changeseq_lst %>%
    map_dfr(read_tsv, .id = "changeseq_run")
```

```{r}
glimpse(changeseq_df)
```

```{r}
unique(changeseq_df$changeseq_run)
```


__NOTE__ - can modify data frame to add lab name, e.g. StJude or NIST, either using file paths or separate data frame.
Annotating using file names
```{r}
## This code is specific to the input file name format
changeseq_anno_df <- changeseq_df %>% 
    mutate(changeseq_run = str_remove(changeseq_run, "_GM24385_identified_matched.txt"),
           sample = "GM24385",
          target_site = str_sub(changeseq_run, 5),
           lab = substr(changeseq_run, 1,3))  %>% 
  ## possible identifiers: NNN, NSN, NSS
  ## first = wet lab, second = sequence, third = bioinformatics

    separate(lab, into = c("wet_lab","seq_lab","bioinf"), 
           sep = c(1,2,3),
           remove = FALSE) %>%
  mutate(wet_lab = if_else(wet_lab == "N", "NIST", "StJude"),
         seq_lab = if_else(seq_lab == "N", "NIST", "StJude"),
         bioinf = if_else(bioinf == "N", "NIST", "StJude"))
changeseq_anno_df
```

__NOTE__ - The lab, target_site, and/ or changeseq_run variables can be used as grouping variables to calculate within dataset summarise.


Annotating data frame with replicate/ info - experimental design
```{r}
## Done with above
```


## Summary/ Statistical Analysis
### Calculating Summary Metrics

### Summary Metric Analysis
#### Plots
#### Table
Replacing code from `changeseq_stats.R`

_Table structure_  

* Total read count
```{r}
total_count_df <- changeseq_df %>% 
    group_by(changeseq_run, lab, target_site) %>% 
    summarise(total_read_count = sum(Nuclease_Read_Count))
```

```{r}
ggplot(total_count_df) + 
    geom_bar(aes(x = target_site, y = total_read_count, fill = lab), 
             position = "dodge", stat = "identity") +
    theme_bw() + 
    theme(axis.text.x = element_text(angle = 90)) + 
    labs(x = "Total Read Count", y = "Editing Target Site", 
         fill = "Sequencing\nLab")
```

* Total on-target read count
```{r}
target_count_df <- changeseq_df %>% 
    filter(Site_Substitution_Number == 0)
```

```{r}
ggplot(target_count_df) + 
    geom_bar(aes(x = target_site, y = Nuclease_Read_Count, fill = lab), 
             position = "dodge", stat = "identity") +
    theme_bw() + 
    theme(axis.text.x = element_text(angle = 90)) + 
    labs(x = "Total Read Count", y = "Editing Target Site", 
         fill = "Sequencing\nLab")
```

```{r}
target_count_df %>% 
    select(target_site, lab, Nuclease_Read_Count) %>% 
    spread(key = target_site, value = Nuclease_Read_Count)
```
```{r}
target_count_df %>% 
    select(target_site, lab, Nuclease_Read_Count) %>% 
    arrange(target_site, lab)
```
* Percent on-target reads (on-target read count/total read count)
```{r}
total_count_df <- changeseq_df %>% 
    group_by(changeseq_run, lab, target_site) %>% 
    summarise(total_read_count = sum(Nuclease_Read_Count))

target_count_df <- changeseq_df %>% 
    filter(Site_Substitution_Number == 0) %>% 
    rename(on_target_count = Nuclease_Read_Count) %>% 
    select(changeseq_run, lab, target_site, on_target_count)

summary_df <- left_join(total_count_df, target_count_df) %>% 
    mutate(on_target_rate = on_target_count/total_read_count)
```
```{r}
glimpse(summary_df)
```

``````{r}
ggplot(summary_df) + 
    geom_point(aes(x = target_site, y = on_target_rate, fill = lab), 
               shape = 21, alpha = 0.5) + 
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90)) +
        labs(x = "Editing Target Site", y = "On Target Rate", 
         fill = "Sequencing\nLab")
```

* Total off-target read count
* Percent off-target read count (off-target read count/total read count)
```{r}
summary_df <- changeseq_df %>% 
    mutate(Site_Substitution_Number = if_else(is.na(Site_Substitution_Number), -1, Site_Substitution_Number), 
            on_target = if_else(Site_Substitution_Number == 0, Nuclease_Read_Count, 0),
           off_target = if_else(on_target == 0, Nuclease_Read_Count, 0)) %>% 
    group_by(changeseq_run, lab, target_site) %>% 
    summarise(total_count = sum(Nuclease_Read_Count),
              total_on_target = sum(on_target),
              total_off_target = sum(off_target),
              off_target_ratio = total_off_target/total_count)
summary_df
```
```{r}
glimpse(summary_df)
```

```{r}
ggplot(summary_df) + 
    geom_point(aes(x = target_site, y = total_off_target, fill = lab), 
               shape = 21, alpha = 0.5) + 
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90))+
    labs(x = "Editing Target Site", y = "Total Off-Target Read Count", 
         fill = "Sequencing\nLab")
```

* Number of sequences with substitutions only
* Number sequences with indels only 
* Number of sequences with two possible representations (substitutions or indels)
```{r}
glimpse(changeseq_df)
```
```{r}
summary_df <- changeseq_df %>%
    ## seqs with subs only = seq in Site_Sequence col only
    mutate(Substitution_Only = if_else(is.na(Site_Sequence), FALSE, TRUE),
        ## seqs with indels only = seq in Site_Sequence_Gaps_Allowed col only
        Indel_Only = if_else(is.na(Site_Sequence_Gaps_Allowed), TRUE, FALSE),
        ## seqs with two possible reps = seq in both cols
        Sub_or_Indel = if_else(is.na(Substitution_Only || Indel_Only), FALSE, TRUE)) %>%
    group_by(changeseq_run, lab, target_site) %>%
    summarise(total_substitution_only_seqs = sum(Substitution_Only),
              total_indels_only = sum(Indel_Only),
              total_sub_or_indel = sum(Sub_or_Indel))

summary_df
```


```{r}
## how do I make a bar plot with this information?
summary_df %>% 
    ## First make the table long
    gather(key = "metric", value = "value", -changeseq_run, -lab, -target_site) %>% 
    ggplot() +
    geom_bar(aes(x = metric, 
                 y = value,
                 fill = lab),
             position = "dodge", 
             stat = "identity"
             ) +
    ## Split plot by summary metric
    facet_wrap(~target_site, scales = "free_y") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = -45, hjust = 0))
```

The following will consider only those with only substitution mismatches:
* On-target to top 25% reads (on-target read count/top 25% off-target read count)
#%#- line 219: How do I now subset the df to consider only the top 25% of off-target read counts?
```{r}
summary_df <- changeseq_df %>%
    mutate(Substitution_Only = if_else(is.na(Site_Sequence), FALSE, TRUE),
           on_target = if_else(Site_Substitution_Number == 0, Nuclease_Read_Count, 0)) %>% 
    filter(Substitution_Only == TRUE) %>%
        arrange(-Nuclease_Read_Count) %>%
    ## Use top_frac to get the top 25% - use group_by to capture within run or site analysis
        top_frac(0.25, wt = Nuclease_Read_Count)
        ## how do I now only subset the top 25% of the df?
summary_df

```

* On-target to most prevalent off-target read (on-target read count/off-target read with largest read count)
#%#- line 235: since I'm piping into this command, how do I reference the first row$Nuclease_Read_Count of the df?
## You can't / don't want to reference the first row instead generate a data frame with the on-target values
```{r}
changeseq_df %>% 
    mutate(Site_Substitution_Number = if_else(is.na(Site_Substitution_Number), -1, Site_Substitution_Number), 
            on_target = if_else(Site_Substitution_Number == 0, Nuclease_Read_Count, 0),
           off_target = if_else(on_target == 0, Nuclease_Read_Count, 0)) %>% 
    group_by(changeseq_run, lab, target_site) %>% 
    summarise(on_target_count = max(on_target),
              off_target_max = max(off_target)) %>% 
    mutate(on_off_max_ratio = on_target_count/ off_target_max)
```

* Read count for seqs w/ 1 substitution from target sequence
* Read count for seqs w/ 2 substitutions from target sequence
* Read count for seqs w/ 3 substitutions from target sequence
* Read count for seqs w/ 4 substitutions from target sequence
* Read count for seqs w/ 5 substitutions from target sequence
* Read count for seqs w/ 6 substitutions from target sequence
#%# - line 251: I'm not doing something correctly here. Want to have bins for 1-6 mismatches and group by target site, lab
```{r}
changeseq_df %>%
    mutate(Substitution_Only = if_else(is.na(Site_Sequence), FALSE, TRUE)) %>% 
    filter(Substitution_Only == TRUE,
           Site_Substitution_Number > 0) %>% 
    group_by(changeseq_run, lab, target_site, Site_Substitution_Number) %>% 
    summarise(read_count = sum(Nuclease_Read_Count))
      
```


### Summary Table 
```{r}
## Potentially use the DT or other packages for visually pleasing table presentation
summary_tbl %>% DT::datatable()
```

## Off-Target Sequence Comparison
re-implementation of code from `CHANGEseq_compare_fulldf.R` and `edited_CHANGEseq_compare_fulldf.R`. 
These scripts aim to reproduce manuscript Figure 1i. 


# Session Information
## System Information
```{r}
sessioninfo::platform_info()
```


## Package Versions
```{r}
sessioninfo::package_info() %>% 
    filter(attached = TRUE) %>% 
    select(package, loadedversion, date, source) %>%
    knitr::kable(booktabs = TRUE, row.names = FALSE)
```